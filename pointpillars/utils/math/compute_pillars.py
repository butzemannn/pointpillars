# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_compute_pillars.ipynb (unless otherwise specified).

__all__ = ['logger', 'remove_invalid_points', 'get_points_in_pillars', 'PillarCalc', 'calculate_pillars']

# Cell

#export
import logging
import torch
import numpy as np
from numba import njit

from utils.io import read_config

logger = logging.getLogger(__name__)


# Cell
def remove_invalid_points(pcloud: torch.tensor,
                          pillars_cfg: dict,
                          dt=torch.float32,
                          dev: str = "cuda:0"):
    """Removes invalid points exceeding the calculation bounds from the point clouds

    :param pcloud: Tensor containing the points from the point cloud
    :param pillars_cfg:

    :returns: pcloud without the points exceeding the calculation bounds
    """
    logger.info("Removing invalid points from point cloud...")

    min = torch.cuda.FloatTensor([pillars_cfg.getfloat("x_min"), pillars_cfg.getfloat("y_min"), pillars_cfg.getfloat("z_min")])
    max = torch.cuda.FloatTensor([pillars_cfg.getfloat("x_max"), pillars_cfg.getfloat("y_max"), pillars_cfg.getfloat("z_max")])

    xyz_points = pcloud[:,:3]
    mask = torch.logical_and(torch.le(min, xyz_points), torch.le(xyz_points, max))
    mask = torch.all(mask, dim=1)

    logger.debug(f"Removing complete.\n"
                 f"pcloud: {pcloud}{pcloud.shape}")
    return pcloud[mask]

# Cell
@njit(parallel=False)
def _get_points_in_pillars(pcloud: np.ndarray,
                           pillars : np.ndarray,
                           pill_ind: np.ndarray,
                           pill_point_nbr: np.ndarray,
                           coor_to_pillar_id: np.ndarray,
                           min: np.ndarray,
                           step: np.ndarray,
                           max_ppp: int):
    """
        pcloud[nbpoints, 4]: array with points from point cloud (should be shuffled)
        pillars[nbpillars, 50, 4]: array with the final pcloud points per pillar (init as zero)
        pill_ind[nbpillars, 2]: x,y index for each pillar (init as zero)
        pill_point_nbr[nbpillars]: non zero points currently in the pillar
        coor_to_pillar_id[x_nbr, y_nbr,1]: with the xy bounds from the pillar get the pillar id (init with -1)

        returns: number of non zero pillars

    """
    N = pcloud.shape[0]
    pill_num = 0
    for i in range(N):
        point = pcloud[i]
        pil_coor = ((point[:2] - min) / step).astype(np.int32)
        pillar_id = coor_to_pillar_id[pil_coor[0], pil_coor[1]]
        # the pillar is not used yet
        if pillar_id == -1:
            pillar_id = pill_num
            coor_to_pillar_id[pil_coor[0], pil_coor[1]] = pillar_id
            pill_num += 1
            # set the correct bound so they can be transformed
            pill_ind[pillar_id] = pil_coor

        # non zero points in current pillar
        p_nbr = pill_point_nbr[pillar_id]
        if p_nbr < max_ppp:
            pillars[pillar_id, p_nbr] = point
            pill_point_nbr[pillar_id] += 1

    return pill_num

# Cell
def get_points_in_pillars(pcloud: torch.Tensor,
                          pillars_cfg: dict,
                          shuffle: bool = True,
                          dev: str = "cuda:0"):
    """
        not shuffling saves about 7ms
    """
    logger.info("Selecting points in pillar...")
    logger.debug(f"pcloud: {pcloud}{pcloud.shape}")

    if shuffle:
        pcloud = pcloud[torch.randperm(pcloud.shape[0])]

    min = np.array((float(pillars_cfg["x_min"]), float(pillars_cfg["y_min"])), dtype=np.float32)
    max = np.array((float(pillars_cfg["x_max"]), float(pillars_cfg["y_max"])), dtype=np.float32)
    step = np.array((float(pillars_cfg["x_step"]), float(pillars_cfg["y_step"])), dtype=np.float32)
    max_ppp = pillars_cfg.getfloat("max_points_per_pillar")
    max_pil = pillars_cfg.getint("max_pillars")
    n_pil = ((max - min) / step).astype(np.int32)
    n_pil_all = n_pil[0] * n_pil[1]

    pillars = np.zeros([n_pil_all, int(max_ppp), 4], dtype=np.float32)
    pill_ind = np.zeros([n_pil_all, 2], dtype=np.float32)
    pill_point_nbr = np.zeros([n_pil_all], dtype=np.int32)
    coor_to_pillar_id = -1 * np.ones(n_pil, dtype=np.int32)
    pcloud = remove_invalid_points(pcloud, pillars_cfg).to("cpu").numpy()

    logger.debug("Running jit method...")
    _get_points_in_pillars(pcloud, pillars, pill_ind, pill_point_nbr, coor_to_pillar_id, min, step, max_ppp)

    pill_tens = torch.from_numpy(pillars[:max_pil]).cuda()
    pill_ind_tens = torch.from_numpy(pill_ind[:max_pil]).cuda()

    logger.debug(f"Point selection complete.\n"
                 f"pill_tens: {pill_tens}{pill_tens.shape},\n"
                 f"pill_ind_tens: {pill_ind_tens}{pill_ind_tens.shape}")
    return pill_tens, pill_ind_tens

# Cell
class PillarCalc():

    def __init__(self, pillars_cfg: dict):
        logger.debug("Initializing PillarCalc module...")
        self.pillars_cfg = pillars_cfg

    def _pillar_centers_from_index(self, xy_index: torch.tensor):
        """
            converts the pillar bounds into centers.  Pillars center shape must be (pillar_nbr, 2] with the
            last dimension being [x_min, y_min] for each pillar
        """
        logger.info("Calculating pillar_centers_from_index.")
        logger.debug(f"xy_index: {xy_index}{xy_index.shape}")

        min = torch.cuda.FloatTensor([self.pillars_cfg.getfloat('x_min'), self.pillars_cfg.getfloat('y_min')])
        step = torch.cuda.FloatTensor([self.pillars_cfg.getfloat('x_step'), self.pillars_cfg.getfloat('y_step')])
        z_center = torch.cuda.FloatTensor([(self.pillars_cfg.getfloat('z_max') - self.pillars_cfg.getfloat('z_min')) / 2.0])

        # bring z center on shape from xy_min for concatenation
        z_center = z_center.unsqueeze(0).expand(xy_index.shape[0], -1)

        # The actual pillar boundaries (min has to be added again)
        xy_index = xy_index * step + min
        xy_index.add_(0.5 * step)
        xy_index = torch.cat((xy_index, z_center), dim=1)

        logger.debug(f"Center calculation complete.\n"
                     f"xy_center: {xy_index}{xy_index.shape},\n"
                     f"z_center: {z_center}{z_center.shape}")

        return xy_index

    def __call__(self, pillars: torch.Tensor, pillar_index: torch.Tensor, dt = torch.float32):
        """Returns the tensor with the given and all the calculated attributes.
            :param pillars:
            :param pillar_index:
            :param dt: datatype for torch tensors

            :returns:
        """
        logger.info("Calculating Pillars..")
        logger.debug(f"pillars: {pillars}{pillars.shape},\n"
                     f"pillar_index: {pillar_index}{pillar_index.shape}")

        # create mask for calculation because already zero padded
        centers = self._pillar_centers_from_index(pillar_index)
        mask = (pillars != 0)[:,:,:3]
        val = pillars[:,:,:3]

        # calculate the mean
        mean = val.mul_(mask).sum(dim=1)
        mean /= mask.sum(dim=1)

        # calculate difference to mean
        mean = mean.unsqueeze(1).expand(-1, val.shape[1], -1).clone()
        mean *= -1 * mask
        mean += val

        # replace the NaN with zeros
        mean[torch.isnan(mean)] = 0

        # calculate difference to centers
        centers = centers.unsqueeze(1).expand(-1, val.shape[1], -1).clone()
        centers *= -1 * mask
        centers += val
        centers = centers[:,:,:2]

        logger.debug(f"Pillar calculation complete.\n"
                     f"pillars: {pillars}{pillars.shape},\n"
                     f"diff_to_mean: {mean}{mean.shape},\n"
                     f"diff_to_center: {centers}{centers.shape}")

        return torch.cat((pillars, mean, centers), dim=2)

# Cell
def calculate_pillars(pcloud : torch.tensor):
    """
        The actual pillar calculation

        :param pcloud: The point cloud from which to extract and calculate pillars

        :returns: List[Tensor(nb_attributes, nbr_pillars w. zero_padding, nb_points_in_pillars),
                        Tensor(nb_pillars, 2)]
                  First tensor containing the points sorted into their corresponding pillar
                  Second Tensor containing the unique index for each pillar to later identify the position
    """
    logger.info("Calculating Pillars...")
    if not torch.is_tensor(pcloud):
        raise ValueError("Tensor expected but not given.")

    pillars_cfg = read_config()['pillars']
    pillars, pillar_index = get_points_in_pillars(pcloud, pillars_cfg, shuffle=True)

    # create model and move to gpu
    model = PillarCalc(pillars_cfg)


    logger.info("Pillar calculation complete!")
    # permutation to receive correct pillar layout with (D,P,N)
    return model(pillars, pillar_index).permute(2,0,1), pillar_index.type(torch.LongTensor)