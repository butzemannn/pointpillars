# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_utils.box_ops.ipynb (unless otherwise specified).

__all__ = ['logger', 'convert_boxes_to_2d_corners', 'convert_boxes_to_3d_corners', 'bb_tensor_to_velodyne_coords',
           'convert_vel_to_cam_coords', 'vel_point_to_left_cam_point']

# Cell
import torch
import logging


# Cell
logger = logging.getLogger(__name__)

# Cell
def convert_boxes_to_2d_corners(boxes: torch.Tensor, batch_dim: bool = True) -> torch.Tensor:
    """Converts center representation to bounding corners
    :param boxes: tensor(batch_size, nbr_boxes, nb_attributes)
    :param batch_dim: Boolean if batch dim is used when converting

    :returns: tensor(batch_size, max_nbr_pred_boxes, 4)
                with last dimension being (x_min, y_min, x_max, y_max)
    """

    if batch_dim:
        xy = boxes[:,:,:2]
        lw = torch.stack((boxes[:,:,5], boxes[:,:,4]), dim=2)
        dim = 2
    else:
        xy = boxes[:,:2]
        lw = torch.stack((boxes[:,5], boxes[:,4]), dim=2)
        dim = 1

    xy_min = xy - 0.5 * lw
    xy_max = xy + 0.5 * lw

    return torch.cat([xy_min, xy_max], dim=dim)

# Cell
def convert_boxes_to_3d_corners(boxes: torch.Tensor, batch_dim: bool = True) -> torch.Tensor:
    """
    Converts center representation to bounding corners. According to Kitti conventions, when calculating
    z_min, 0 is subtracted and h is added to reach z_max.

    :param boxes: Tensor(nbr_batches, nbr_boxes, 7) with latest dim being (x,y,z,h,w,l,theta)
    :param batch_dim: Boolean if batch dimension is used when converting.

    :returns: Tensor(nbr_batches, nbr_boxes, 6)
                with latest dim being (x_min, y_min, z_min, x_max, y_max, z_max)
    """
    if batch_dim:
        xyz = boxes[:,:,:3]
        lw = torch.stack((boxes[:,:,5], boxes[:,:,4]), dim=2)
        h = boxes[:,:,3].unsqueeze(2)
        dim = 2
    else:
        xyz = boxes[:,:3]
        lw = torch.stack((boxes[:,5], boxes[:,4]), dim=1)
        h = boxes[:,3].unsqueeze(1)
        dim = 1

    zeros = torch.zeros_like(h, device="cuda:0")
    xyz_min = xyz - torch.cat((0.5 * lw, zeros), dim=dim)
    xyz_max = xyz + torch.cat((0.5 * lw, h), dim=dim)

    return torch.cat([xyz_min, xyz_max], dim=dim)


# Cell
def bb_tensor_to_velodyne_coords(bb_cam: torch.Tensor):
    xc, yc, zc, box_dims = bb_cam[:,0], bb_cam[:, 1], bb_cam[:, 2], bb_cam[:, 3:]

    xv = zc
    yv = -1 * xc
    zv = -1 * yc

    return torch.cat((xv.unsqueeze(1), yv.unsqueeze(1), zv.unsqueeze(1), box_dims), dim=1)


# Cell
def convert_vel_to_cam_coords(point: torch.Tensor, batch_dim: bool = True) -> torch.Tensor:
    """
    Converts from velodyne coordinates to
    """
    if batch_dim:
        # TODO: implement batch_dim option
        raise NotImplementedError("batch_dim option not yet implemented.")



# Cell
def vel_point_to_left_cam_point(y: torch.Tensor, calib_file: str) -> torch.Tensor:
    """
     Convert vel point to left color image:
     x = P2 * R0_rect * Tr_velo_to_cam * y

     :returns: Tensor(4) with x,y,z,1 in image coordinates and system
    """
    # load transform data from calib folder


    with open(calib_file, 'r') as f:
        lines = f.readlines()
        P2_l = [float(x) for x in lines[2].split(" ")[1:]]
        R0_l = [float(x) for x in lines[4].split(" ")[1:]]
        Tr_l = [float(x) for x in lines[5].split(" ")[1:]]

    P2 = torch.tensor([[P2_l[0], P2_l[1], P2_l[2], P2_l[3]],
                       [P2_l[4], P2_l[5], P2_l[6], P2_l[7]],
                       [P2_l[8], P2_l[9], P2_l[10], P2_l[11]]], device=torch.device("cuda"))
    R0 = torch.tensor([[R0_l[0], R0_l[1], R0_l[2], 0],
                       [R0_l[3], R0_l[4], R0_l[5], 0],
                       [R0_l[6], R0_l[7], R0_l[8], 0],
                       [0,       0,       0,       1]], device=torch.device("cuda"))
    Tr = torch.tensor([[Tr_l[0], Tr_l[1], Tr_l[2],  Tr_l[3]],
                       [Tr_l[4], Tr_l[5], Tr_l[6],  Tr_l[7]],
                       [Tr_l[8], Tr_l[9], Tr_l[10], Tr_l[11]],
                       [0,       0,       0,        1]], device=torch.device("cuda"))

    return P2 @ R0 @ Tr @ y